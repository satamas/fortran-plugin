{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'
  parserUtilClass='org.jetbrains.fortran.lang.parser.FortranParserUtil'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    ARRAYLBR  = '(/'
    ARRAYRBR  = '/)'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'

    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'
    UNDERSCORE = '_'
    AMPERSAND = '&'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE  = '.true.'
    FALSE = '.false.'

    POINTER_ASSMNT = '=>'

    // for the external rule
    LABELED_DO_CONSTRUCT = 'LABELED_DO_CONSTRUCT'
    LABEL_DO_STMT = 'LABEL_DO_STMT'
    DO_TERM_ACTION_STMT = 'DO_TERM_ACTION_STMT'
    IDENTIFIER = 'identifier'
  ]

  extends(".*(_expr|literal)")=expr
  implements("(program_stmt|function_stmt|subroutine_stmt|mp_subprogram_stmt|block_data_stmt|module_stmt|submodule_stmt)")='org.jetbrains.fortran.lang.psi.FortranBeginUnitStmt'
  implements("(end_program_stmt|end_function_stmt|end_subroutine_stmt|end_mp_subprogram_stmt|end_block_data_stmt|end_module_stmt|end_submodule_stmt)")='org.jetbrains.fortran.lang.psi.FortranEndUnitStmt'
  implements("(associate_stmt|block_stmt|select_case_stmt|critical_stmt|nonlabel_do_stmt|labeled_do_stmt_stmt|forall_construct_stmt|if_then_stmt|select_type_stmt|where_construct_stmt)")='org.jetbrains.fortran.lang.psi.FortranBeginConstructStmt'
  elementTypeFactory("(program_stmt|function_stmt|subroutine_stmt|mp_subprogram_stmt|block_data_stmt|module_stmt|submodule_stmt)") ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
  stubClass("(program_stmt|function_stmt|subroutine_stmt|mp_subprogram_stmt|block_data_stmt|module_stmt|submodule_stmt)") = 'org.jetbrains.fortran.lang.stubs.FortranStatementStub'
  mixin("(program_stmt|function_stmt|subroutine_stmt|mp_subprogram_stmt|block_data_stmt|module_stmt|submodule_stmt)") = "org.jetbrains.fortran.lang.psi.mixin.FortranStmtImplMixin"
  implements(".*_stmt")='org.jetbrains.fortran.lang.psi.FortranStmt'
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

file ::= eol* program

// keywords parsing list for keywords parsing as identifiers
private abstract_      ::= <<parseKeyword "ABSTRACT">>
private accept_        ::= <<parseKeyword "ACCEPT">>
private all_           ::= <<parseKeyword "ALL">>
private allocate_      ::= <<parseKeyword "ALLOCATE">>
private allocatable_   ::= <<parseKeyword "ALLOCATABLE">>
private assign_        ::= <<parseKeyword "ASSIGN">>
private assignment_    ::= <<parseKeyword "ASSIGNMENT">>
private associate_     ::= <<parseKeyword "ASSOCIATE">>
private asynchronous_  ::= <<parseKeyword "ASYNCHRONOUS">>
private backspace_     ::= <<parseKeyword "BACKSPACE">>
private bind_          ::= <<parseKeyword "BIND">>
private block_         ::= <<parseKeyword "BLOCK">>
private blockdata_     ::= <<parseKeyword "BLOCKDATA">>
private byte_          ::= <<parseKeyword "BYTE">>
private call_          ::= <<parseKeyword "CALL">>
private case_          ::= <<parseKeyword "CASE">>
private character_     ::= <<parseKeyword "CHARACTER">>
private class_         ::= <<parseKeyword "CLASS">>
private close_         ::= <<parseKeyword "CLOSE">>
private codimension_   ::= <<parseKeyword "CODIMENSION">>
private complex_       ::= <<parseKeyword "COMPLEX">>
private common_        ::= <<parseKeyword "COMMON">>
private concurrent_    ::= <<parseKeyword "CONCURRENT">>
private contains_      ::= <<parseKeyword "CONTAINS">>
private contiguous_    ::= <<parseKeyword "CONTIGUOUS">>
private continue_      ::= <<parseKeyword "CONTINUE">>
private critical_      ::= <<parseKeyword "CRITICAL">>
private cycle_         ::= <<parseKeyword "CYCLE">>
private data_          ::= <<parseKeyword "DATA">>
private deallocate_    ::= <<parseKeyword "DEALLOCATE">>
private decode_        ::= <<parseKeyword "DECODE">>
private default_       ::= <<parseKeyword "DEFAULT">>
private deferred_      ::= <<parseKeyword "DEFERRED">>
private dimension_     ::= <<parseKeyword "DIMENSION">>
private do_            ::= <<parseKeyword "DO">>
private double_        ::= <<parseKeyword "DOUBLE">>
private doubleprecision_ ::= <<parseKeyword "DOUBLEPRECISION">>
private doublecomplex_ ::= <<parseKeyword "DOUBLECOMPLEX">>
private elemental_     ::= <<parseKeyword "ELEMENTAL">>
private else_          ::= <<parseKeyword "ELSE">>
private elseif_        ::= <<parseKeyword "ELSEIF">>
private elsewhere_     ::= <<parseKeyword "ELSEWHERE">>
private encode_        ::= <<parseKeyword "ENCODE">>
private end_           ::= <<parseKeyword "END">>
private endassociate_  ::= <<parseKeyword "ENDASSOCIATE">>
private endblock_      ::= <<parseKeyword "ENDBLOCK">>
private endblockdata_  ::= <<parseKeyword "ENDBLOCKDATA">>
private endcritical_   ::= <<parseKeyword "ENDCRITICAL">>
private enddo_         ::= <<parseKeyword "ENDDO">>
private endenum_       ::= <<parseKeyword "ENDENUM">>
private endfile_       ::= <<parseKeyword "ENDFILE">>
private endforall_     ::= <<parseKeyword "ENDFORALL">>
private endfunction_   ::= <<parseKeyword "ENDFUNCTION">>
private endif_         ::= <<parseKeyword "ENDIF">>
private endinterface_  ::= <<parseKeyword "ENDINTERFACE">>
private endmodule_     ::= <<parseKeyword "ENDMODULE">>
private endprocedure_  ::= <<parseKeyword "ENDPROCEDURE">>
private endprogram_    ::= <<parseKeyword "ENDPROGRAM">>
private endselect_     ::= <<parseKeyword "ENDSELECT">>
private endsubmodule_  ::= <<parseKeyword "ENDSUBMODULE">>
private endsubroutine_ ::= <<parseKeyword "ENDSUBROUTINE">>
private endtype_       ::= <<parseKeyword "ENDTYPE">>
private endwhere_      ::= <<parseKeyword "ENDWHERE">>
private entry_         ::= <<parseKeyword "ENTRY">>
private enum_          ::= <<parseKeyword "ENUM">>
private enumerator_    ::= <<parseKeyword "ENUMERATOR">>
private error_         ::= <<parseKeyword "ERROR">>
private equivalence_   ::= <<parseKeyword "EQUIVALENCE">>
private exit_          ::= <<parseKeyword "EXIT">>
private extends_       ::= <<parseKeyword "EXTENDS">>
private external_      ::= <<parseKeyword "EXTERNAL">>
private final_         ::= <<parseKeyword "FINAL">>
private flush_         ::= <<parseKeyword "FLUSH">>
private forall_        ::= <<parseKeyword "FORALL">>
private format_        ::= <<parseKeyword "FORMAT">>
private formatted_     ::= <<parseKeyword "FORMATTED">>
private function_      ::= <<parseKeyword "FUNCTION">>
private generic_       ::= <<parseKeyword "GENERIC">>
private go_            ::= <<parseKeyword "GO">>
private goto_          ::= <<parseKeyword "GOTO">>
private if_            ::= <<parseKeyword "IF">>
private images_        ::= <<parseKeyword "IMAGES">>
private implicit_      ::= <<parseKeyword "IMPLICIT">>
private import_        ::= <<parseKeyword "IMPORT">>
private impure_        ::= <<parseKeyword "IMPURE">>
private in_            ::= <<parseKeyword "IN">>
private include_       ::= <<parseKeyword "INCLUDE">>
private inout_         ::= <<parseKeyword "INOUT">>
private integer_       ::= <<parseKeyword "INTEGER">>
private intent_        ::= <<parseKeyword "INTENT">>
private interface_     ::= <<parseKeyword "INTERFACE">>
private intrinsic_     ::= <<parseKeyword "INTRINSIC">>
private inquire_       ::= <<parseKeyword "INQUIRE">>
private iolength_      ::= <<parseKeyword "IOLENGTH">>
private is_            ::= <<parseKeyword "IS">>
private kind_          ::= <<parseKeyword "KIND">>
private len_           ::= <<parseKeyword "LEN">>
private lock_          ::= <<parseKeyword "LOCK">>
private logical_       ::= <<parseKeyword "LOGICAL">>
private memory_        ::= <<parseKeyword "MEMORY">>
private module_        ::= <<parseKeyword "MODULE">>
private name_          ::= <<parseKeyword "NAME">>
private namelist_      ::= <<parseKeyword "NAMELIST">>
private none_          ::= <<parseKeyword "NONE">>
private nonintrinsic_  ::= <<parseKeyword "NONINTRINSIC">>
private nonoverridable_ ::= <<parseKeyword "NON_OVERRIDABLE">>
private nopass_        ::= <<parseKeyword "NOPASS">>
private nullify_       ::= <<parseKeyword "NULLIFY">>
private only_          ::= <<parseKeyword "ONLY">>
private open_          ::= <<parseKeyword "OPEN">>
private operator_      ::= <<parseKeyword "OPERATOR">>
private optional_      ::= <<parseKeyword "OPTIONAL">>
private out_           ::= <<parseKeyword "OUT">>
private parameter_     ::= <<parseKeyword "PARAMETER">>
private pass_          ::= <<parseKeyword "PASS">>
private pause_         ::= <<parseKeyword "PAUSE">>
private pointer_       ::= <<parseKeyword "POINTER">>
private precision_     ::= <<parseKeyword "PRECISION">>
private print_         ::= <<parseKeyword "PRINT">>
private private_       ::= <<parseKeyword "PRIVATE">>
private procedure_     ::= <<parseKeyword "PROCEDURE">>
private program_       ::= <<parseKeyword "PROGRAM">>
private protected_     ::= <<parseKeyword "PROTECTED">>
private public_        ::= <<parseKeyword "PUBLIC">>
private pure_          ::= <<parseKeyword "PURE">>
private read_          ::= <<parseKeyword "READ">>
private real_          ::= <<parseKeyword "REAL">>
private recursive_     ::= <<parseKeyword "RECURSIVE">>
private result_        ::= <<parseKeyword "RESULT">>
private return_        ::= <<parseKeyword "RETURN">>
private rewind_        ::= <<parseKeyword "REWIND">>
private save_          ::= <<parseKeyword "SAVE">>
private select_        ::= <<parseKeyword "SELECT">>
private sequence_      ::= <<parseKeyword "SEQUENCE">>
private stop_          ::= <<parseKeyword "STOP">>
private sync_          ::= <<parseKeyword "SYNC">>
private syncall_       ::= <<parseKeyword "SYNCALL">>
private syncimages_    ::= <<parseKeyword "SYNCIMAGES">>
private syncmemory_    ::= <<parseKeyword "SYNCMEMORY">>
private subroutine_    ::= <<parseKeyword "SUBROUTINE">>
private submodule_     ::= <<parseKeyword "SUBMODULE">>
private target_        ::= <<parseKeyword "TARGET">>
private then_          ::= <<parseKeyword "THEN">>
private to_            ::= <<parseKeyword "TO">>
private type_          ::= <<parseKeyword "TYPE">>
private unformatted_   ::= <<parseKeyword "UNFORMATTED">>
private unlock_        ::= <<parseKeyword "UNLOCK">>
private use_           ::= <<parseKeyword "USE">>
private value_         ::= <<parseKeyword "VALUE">>
private volatile_      ::= <<parseKeyword "VOLATILE">>
private wait_          ::= <<parseKeyword "WAIT">>
private where_         ::= <<parseKeyword "WHERE">>
private while_         ::= <<parseKeyword "WHILE">>
private write_         ::= <<parseKeyword "WRITE">>
private unit_          ::= <<parseKeyword "UNIT">>

// Clause 0
// System parts needed for this implementation
// format is *, label or expression, matches all possibilities in specifications
parameters_spec ::= !')' fidentifier '=' parameter_value {
  pin = 1
  recoverWhile = parameter_spec_recover
}

parameters_spec_with_unit ::= !')' (((unit_ '=')? unit_or_expression !'=') | (fidentifier '=' parameter_value)) {
  pin = 1
  recoverWhile = parameter_spec_recover
  elementType = parameters_spec
}

parameters_spec_with_unit_decl ::= !')' (((unit_ '=')? unit_decl_or_expression !'=') | (fidentifier '=' parameter_value)) {
  pin = 1
  recoverWhile = parameter_spec_recover
  elementType = parameters_spec
}

io_unit_spec ::= (unit_ '=')? ('*' | unit_or_expression) { elementType = parameters_spec}
private io_control_spec_list ::= ( io_unit_spec ',' parameter_value !'=' (',' <<list parameters_spec>>)?)
                                | (io_unit_spec (',' <<list parameters_spec>>)?)
                                | <<list parameters_spec_with_unit>>

private parameter_spec_recover ::= !(')' | ',')
private label_or_expression ::= label !expr_sign | expr
private unit_or_expression ::= unit !expr_sign | expr
private unit_decl_or_expression ::= unit_decl !expr_sign | expr
private expr_sign ::= (defoperator | '.eqv.' | '.neqv.' | '.or.' | '.and.' | '.not.'
                       | rel_op | '//' | '+' | '-' | '*' | '/' | '**' | '(' | '[')

// Clause 1 (ready)
// R101
private meta list ::= <<param>> ( ',' <<param>> )*
private meta noncomalist ::= <<param>> ( ','? <<param>> )*
// R102 and R103 are trivial
external fidentifier ::= parseIdentifier

private string_literal ::= stringliteral | multiline_string_literal
multiline_string_literal ::= (stringstart (stringmiddle)* stringend)

// Clause 2
// R201
private program ::=  (eol | program_unit)*
// R202
program_unit ::= !<<eof>> (external_subprogram | module | submodule | block_data | include_stmt | main_program ) {
  pin = 1
  recoverWhile = program_unit_recover
  implements = ["org.jetbrains.fortran.lang.psi.ext.FortranNamedElement"
                "org.jetbrains.fortran.lang.psi.ext.FortranEntitiesOwner"
                "com.intellij.psi.PsiNameIdentifierOwner"]
  mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranProgramUnitImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
private program_unit_recover ::= !(eol | end_unit_keys)
private end_unit_keys ::= !assignment_stmt (label_decl? (end_ | endprogram_ | endmodule_
                        | endfunction_ | endsubroutine_ | endsubmodule_))
// R203
private external_subprogram ::= function_subprogram | subroutine_subprogram
// R204 - 206 are included into execution_part_construct to be in block
// We prefer to parse more and then check
// R207
declaration_construct ::= derived_type_def | enum_def | interface_block {
    implements = ["org.jetbrains.fortran.lang.psi.ext.FortranNamedElement"
                  "org.jetbrains.fortran.lang.psi.ext.FortranEntitiesOwner"]
}

declaration_stmt ::= entry_stmt | format_stmt | parameter_stmt | procedure_declaration_stmt
                        | specification_stmt | type_declaration_stmt | stmt_function_stmt
// R208 is in R801
// R209
private execution_part_construct ::= !(end_block_keys) ( action_stmt | labeled_do_construct | executable_construct
                                     | use_stmt | include_stmt | import_stmt | implicit_stmt | declaration_construct
                                     | declaration_stmt | type_stmt) {
  pin=1
  recoverWhile=block_recover
}
private block_recover ::= !(eol | end_block_keys)
private end_block_keys ::= !assignment_stmt ( label_decl? ( end_ | endblock_ | endcritical_ | enddo_ | endfunction_ | endif_ | endmodule_ | endprocedure_
                         | endprogram_ | endselect_ | endsubroutine_ | else_ | elseif_ | endassociate_ | case_ | contains_stmt | endwhere_
                         | endforall_ | elsewhere_ | (type_ is_) | (class_ is_) | (class_ default_)))
// R210
internal_subprogram_part ::= contains_stmt eol+ (eol | internal_subprogram)* {
pin = 1
    elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranInternalSubprogramPartStub'
    mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranInternalSubprogramPartImplMixin'
}
// R211
private internal_subprogram ::= !(label_decl? (end_unit_keys | endprocedure_)) (function_subprogram | subroutine_subprogram) {
  pin = 1
  recoverWhile=internal_subprogram_recover
}
private internal_subprogram_recover ::= !(eol | end_ | endfunction_ | endsubroutine_ | endprocedure_)
// R212
specification_stmt ::=  access_stmt |  allocatable_stmt |  asynchronous_stmt
                           |  bind_stmt         |  codimension_stmt |  common_stmt
                           |  data_stmt         |  dimension_stmt   |  equivalence_stmt
                           |  external_stmt     |  intent_stmt      |  intrinsic_stmt
                           |  namelist_stmt     |  optional_stmt    |  pointer_stmt
                           |  protected_stmt    |  save_stmt        |  target_stmt
                           |  volatile_stmt     |  value_stmt       |  contiguous_stmt
{ extends=declaration_stmt }
// R213
executable_construct ::= associate_construct | block_construct       | case_construct
                       | critical_construct  | nonlabel_do_construct | forall_construct
                       | if_construct        | select_type_construct | where_construct
// R214
action_stmt ::= assignment_stmt | pointer_assignment_stmt   | allocate_stmt   | backspace_stmt
                | call_stmt             | close_stmt                | continue_stmt
                | cycle_stmt            | deallocate_stmt           | endfile_stmt
                | error_stop_stmt       | exit_stmt                 | flush_stmt
                | forall_stmt           | goto_stmt                 | if_stmt
                | inquire_stmt          | lock_stmt                 | nullify_stmt
                | open_stmt             | print_stmt
                | read_stmt             | return_stmt               | rewind_stmt
                | stop_stmt             | sync_all_stmt             | sync_images_stmt
                | sync_memory_stmt      | unlock_stmt               | wait_stmt
                | where_stmt            | write_stmt                | arithmetic_if_stmt
                | computed_goto_stmt
                // deleted
                | pause_stmt            | assign_stmt               | assigned_goto_stmt
                // nonstandard
                | accept_stmt           | encode_stmt               | decode_stmt

// R215 is trivial

// Clause 3 (probably ready)
// R301, R302, R303 are implemented is lexer 'name' is replaced by 'identifier'
// R304, R305 are implemented in Clause 7
// R306, R307, R308 are trivial
// R309, R310, R311 are excess
// R312
label_decl ::= integerliteral {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranNamedElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranLabelDeclImplMixin'
}
label ::= integerliteral {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranReferenceElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranLabelImplMixin'
}
unit_decl ::= integerliteral {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranNamedElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranUnitDeclImplMixin'
}
unit ::= integerliteral {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranReferenceElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranUnitImplMixin'
}
construct_name_decl ::= fidentifier  ':' {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranNamedElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranConstructNameDeclImplMixin'
}
construct_name ::= fidentifier {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranReferenceElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranConstructNameImplMixin'
}
// Clause 4
// R401
private type_param_value ::= '*' | ':' | expr
// R402
private type_spec ::= intrinsic_type_spec | derived_type_spec
// R403
private declaration_type_spec ::= intrinsic_type_spec | (type_ '(' (intrinsic_type_spec | derived_type_spec)')')
                                | (class_ '(' (derived_type_spec | '*') ')')
// R404
private intrinsic_type_spec ::= ( number_type_spec | character_type_spec | byte_type_spec/* nonstandard type*/)
                        !('=' | '=>' | '[' | '%') { pin = 2 }

number_type_spec ::= number_type_keyword (kind_selector | nonstandard_kind_selector)?
private number_type_keyword ::= (integer_ | real_ | complex_ | logical_ | (double_ precision_) | doubleprecision_
                                         | (double_ complex_) | doublecomplex_)

character_type_spec ::= (character_ (char_selector)?)

byte_type_spec ::= byte_

// R405
kind_selector ::= '(' (kind_ '=')? expr ')' {pin = 3}
nonstandard_kind_selector ::= '*' expr { pin = 1 }
// R406
signed_int_literal ::= ('+' | '-')? integerliteral
// R407 - 411 are trivial or implemented in lexer
// R412
signed_real_literal ::= ('+' | '-')? (floatingpointliteral | doubleprecisionliteral)
// R412 - 416 are implemented in lexer
// R417
complex_literal ::= '(' ri_part ',' ri_part ')' { pin = 3 }
// R418 - 419
private ri_part ::= signed_int_literal | signed_real_literal | data_name
// R420
char_selector ::= length_selector | ('(' len_ '=' type_param_value ',' kind_ '=' expr ')')
                 | ('(' type_param_value ',' (kind_ '=')? expr ')')
                 | ('(' kind_ '=' expr (',' len_ '=' type_param_value)? ')')
// R421
length_selector ::= ('(' (len_ '=')? type_param_value ')') | ('*' char_length (',' !attr_spec)?)
// R422
char_length ::= ('(' type_param_value ')') | integerliteral
// R423 - 424 are implemented in lexer
// R425
derived_type_def ::= derived_type_stmt eol+ (type_param_def_stmt eol+)* (private_or_sequence eol+)* component_part
                     type_bound_procedure_part? end_type_stmt {
    pin = 1; extends = declaration_construct
    mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranDerivedTypeDefImplMixin"
    elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranDerivedTypeDefStub'
}
type_name ::= fidentifier { extends = data_name
  mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranTypeNameImplMixin"
  elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranDataPathStub'
}
type_decl ::= fidentifier { extends = entity_decl
   mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranTypeDeclMixin"
   elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
   stubClass = 'org.jetbrains.fortran.lang.stubs.FortranEntityDeclStub'
}
// R426
derived_type_stmt ::= label_decl? type_ ((',' <<list type_attr_spec>>)? '::')? type_decl ('(' <<list fidentifier>> ')')?  { pin = 4 }

// R427
type_attr_spec ::= abstract_ | access_spec | (bind_ '(' fidentifier ')') | (extends_ '(' type_name ')')
// R428
private private_or_sequence ::= label_decl? (private_ | sequence_)  { pin = 2 }
// R429
end_type_stmt ::= label_decl? ((end_ type_) | endtype_) type_name? { pin = 2 }
// R430 is trivial
// R431
type_param_def_stmt ::= label_decl? integer_ (kind_selector)? ',' type_param_attr_spec '::' <<list type_param_decl>>
// R432
type_param_decl ::= fidentifier ('=' expr)?
// R433
type_param_attr_spec ::= kind_ | len_
// R434
component_part ::= (component_def_stmt eol+)*
// R435
component_def_stmt ::= !(label_decl? (type_end_keys | contains_)) label_decl? (data_component_def_stmt | proc_component_def_stmt) {
 pin = 1
 recoverWhile = component_def_stmt_recover
}
private component_def_stmt_recover ::= !(eol | type_end_keys | contains_)
// R436
data_component_def_stmt ::= label_decl? declaration_type_spec ((',' <<list component_attr_spec>>)? '::')? <<list component_decl>>
// R437
component_attr_spec ::= access_spec | allocatable_ | (codimension_ '[' coarray_spec ']')
                       | contiguous_ | (dimension_ '(' component_array_spec ')') | pointer_
// R438
component_decl ::= local_name ('(' component_array_spec ')')? ('[' coarray_spec ']')?
                   ('*' char_length)? (initialization)?
// R439
private component_array_spec ::= <<list explicit_shape_spec>> | <<list deferred_shape_spec>>
// R440
proc_component_def_stmt ::= procedure_ '(' proc_interface? ')'',' <<list proc_component_attr_spec>> '::' <<list proc_decl>> { pin = 1 }
// R441
proc_component_attr_spec ::= pointer_ | (pass_ ('(' fidentifier ')')?) | nopass_ | access_spec
// R442 is the same as R505
// R443 - 444 are trivial
// R445
type_bound_procedure_part ::= contains_stmt eol+ (private_stmt eol+)? (type_bound_proc_binding eol+)* { pin = 1 }
// R446
private_stmt ::= label_decl? private_ { pin = 2 }
// R447
private type_bound_proc_binding ::= !(label_decl? type_end_keys) (type_bound_procedure_stmt | type_bound_generic_stmt | final_procedure_stmt) {
 pin = 1
 recoverWhile = type_proc_recover
}
private type_proc_recover ::= !(eol | type_end_keys)
private type_end_keys ::= !assignment_stmt label_decl? (end_ | endtype_)
// R448
type_bound_procedure_stmt ::= label_decl? procedure_ (type_bound_procedure_stmt_part1 | type_bound_procedure_stmt_part2 ) { pin = 2 }
private type_bound_procedure_stmt_part1 ::= '(' fidentifier ')' ',' <<list binding_attr>> '::' <<list fidentifier>> { pin = 1 }
private type_bound_procedure_stmt_part2 ::= ((',' <<list binding_attr>>)? '::')? <<list type_bound_proc_decl>>
// R449
type_bound_proc_decl ::= local_name ('=>' data_name)?
// R450
type_bound_generic_stmt ::= label_decl? generic_ (',' access_spec)? '::' ((fidentifier !'(') | generic_spec) '=>' <<list fidentifier>> { pin = 2}
// R451
binding_attr ::= (pass_ ('(' fidentifier ')')?) | nopass_ | nonoverridable_ | deferred_ | access_spec
// R452
final_procedure_stmt ::= label_decl? final_ '::' <<list fidentifier>> { pin = 2 }
// R453
derived_type_spec ::= type_name ('(' <<list type_param_spec>> ')')? { pin = 1 }
// R454
type_param_spec ::= (fidentifier '=')? type_param_value
// R455 is in clause 7
// R456
component_spec ::= (fidentifier '=')? component_data_source
// R457
component_data_source ::= expr /*| variable*/ | proc_target
// R458
enum_def ::= enum_def_stmt (eol | enumerator_def_stmt)* end_enum_stmt {
 pin = 1; extends = declaration_construct
 mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranEnumDefImplMixin"
 elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
 stubClass = 'org.jetbrains.fortran.lang.stubs.FortranEnumDefStub'
}
// R459
enum_def_stmt ::= label_decl? enum_ ',' bind_ '(' fidentifier ')' { pin = 4 }
// R460
enumerator_def_stmt ::=  label_decl? enumerator_ ('::')? <<list enumerator>> {
  pin = 2;
  recoverWhile = enum_recover
}
private end_enum_keys ::= !assignment_stmt end_enum_stmt
private enum_recover ::= !(eol | end_enum_keys)

// R461
enumerator ::= local_name ('=' expr)?
// R462
end_enum_stmt ::= label_decl? ((end_ enum_) | endenum_) { pin = 2 }
// R463
boz_literal ::= binaryliteral | octalliteral | hexliteral
// R464 - R467 are implemented in lexer
// R468 is in clause 7
// R469
ac_spec ::= ((type_spec '::')? <<list ac_value>>) | (type_spec '::')
// R470 - 471 are trivial
// R472
ac_value ::= ( ac_implied_do | expr) !'=' { pin = 2 }
// R473
ac_implied_do ::= '('<<list ac_value>> ',' id_loop_stmt ')'
// R474 - 475 are trivial

// Clause 5
// R501
type_declaration_stmt ::= label_decl? declaration_type_spec ((',' attr_spec)* '::')? <<list (entity_decl)>> {
    pin=2; extends=declaration_stmt
    elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranStatementStub'
    mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranStmtImplMixin'
}
// R502
attr_spec ::= access_spec | allocatable_ | asynchronous_ | (codimension_ '[' coarray_spec ']')
             | contiguous_ | (dimension_ '(' array_spec ')') | external_
             | (intent_ '(' intent_spec ')') | intrinsic_ | language_binding_spec
             | optional_ | parameter_ | pointer_ | protected_ | save_ | target_ | value_ | volatile_
// R503
entity_decl ::= fidentifier ('(' array_spec ')')? ('[' coarray_spec ']')?
                ('*' char_length)? initialization? {
  implements = [ "org.jetbrains.fortran.lang.psi.ext.FortranNamedElement" ]
  mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranEntityDeclMixin"
  elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranEntityDeclStub'
}
program_unit_name ::= fidentifier { elementType = entity_decl }
// R504 is trivial
// R505
private initialization ::= ('=' expr) | ('=>' designator) | ('=>' function_reference) | ('/' <<list data_stmt_value>> '/')
// R506 is trivial
// R507
private access_spec ::= (public_ | private_)
// R508
language_binding_spec ::= bind_ '(' fidentifier (',' name_ '=' expr)? ')'
// R509
private coarray_spec ::= <<list ':'>> | explicit_coshape_spec
// R510 is trivial
// R511
explicit_coshape_spec ::= ((expr ':')? expr ',')* (expr ':')? '*'
// R512 - 513 are trivial
// R514 is probably unused
// R515
private array_spec ::= assumed_size_spec | <<list implied_shape_spec>> | <<list explicit_shape_spec>>
                     | <<list assumed_shape_spec>> | <<list deferred_shape_spec>>
// R516
explicit_shape_spec ::= (expr ':')? expr
// R517 - 518 are trivial
// R519
assumed_shape_spec ::= (expr)? ':'
// R520
deferred_shape_spec ::= ':'
// R521
assumed_size_spec ::= (explicit_shape_spec ',')* (expr ':')? '*'
// R522
implied_shape_spec ::= (expr ':')? '*'
// R523
private intent_spec ::= in_ | out_ | inout_
// R524
access_stmt ::= label_decl? access_spec (('::')? <<list access_id>>)? { pin = 2; extends=specification_stmt }
// R525
access_id ::= fidentifier | generic_spec // generic_spec includes identifier
// R526
allocatable_stmt ::= label_decl? allocatable_ ('::')? <<list allocatable_decl>> { pin = 2; extends=specification_stmt }
// R527
allocatable_decl ::= data_path ('(' array_spec ')')? ('[' coarray_spec ']')?
// R528
asynchronous_stmt ::= label_decl? asynchronous_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R529
bind_stmt ::= label_decl? language_binding_spec ('::')? <<list bind_entity>> { extends=specification_stmt}
// R530
bind_entity ::= fidentifier | ('/' fidentifier '/')
// R531
codimension_stmt ::= label_decl? codimension_  ('::')? <<list codimension_decl>> { pin = 2; extends=specification_stmt }
// R532
codimension_decl ::= data_name '[' coarray_spec ']'
// R533 unused in standard but works
contiguous_stmt ::= label_decl? contiguous_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R534
data_stmt ::= label_decl? data_ <<list data_stmt_set>> { pin=2; extends=specification_stmt }
// R535
data_stmt_set ::= <<list data_stmt_object>> '/' <<list data_stmt_value>> '/'
// R536
data_stmt_object ::= variable | data_implied_do
// R537
data_implied_do ::= '(' <<list data_i_do_object>> ',' data_name '=' expr ',' expr (',' expr)?  ')'
// R538
data_i_do_object ::= (data_path | data_implied_do) !'=' { pin= 2 }
// R539 is trivial
// R540
data_stmt_value ::= (data_stmt_repeat '*')? data_stmt_constant
// R541
data_stmt_repeat ::= designator | constant
// R542
data_stmt_constant ::= designator | constant | signed_int_literal | signed_real_literal
                     | function_reference | structure_constructor
// R543 - 544 are trivial
// R545
dimension_stmt ::= label_decl? dimension_ ('::')? data_name '(' array_spec ')' (',' data_name '(' array_spec ')')* { pin = 2; extends=specification_stmt }
// R546
intent_stmt ::= label_decl? intent_ '(' intent_spec ')' ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R547
optional_stmt ::= label_decl? optional_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R548
parameter_stmt ::= standard_parameter_stmt | nonstandard_parameter_stmt { extends=declaration_stmt}
private standard_parameter_stmt ::= label_decl? parameter_ '(' <<list named_constant_def>> ')' {pin = 4}
private nonstandard_parameter_stmt ::= label_decl? parameter_  <<list named_constant_def>>  {pin = 3}

// R549
named_constant_def ::= fidentifier '=' expr
// R550
pointer_stmt ::= label_decl? pointer_ ('::')? <<list pointer_decl>> { pin = 2; extends=specification_stmt }
// R551
pointer_decl ::= data_name ('(' <<list deferred_shape_spec>> ')')?
// R552
protected_stmt ::= label_decl? protected_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R553
save_stmt ::= label_decl? save_ (('::')? <<list saved_entity>>)? { pin = 2; extends=specification_stmt }
// R554
saved_entity ::= data_name | ('/' fidentifier '/')
// R555 is trivial
// R556
target_stmt ::= label_decl? target_ ('::')? <<list target_decl>> { pin = 2; extends=specification_stmt }
// R557
target_decl ::= data_name ('(' array_spec ')')? ('[' coarray_spec ']')?
// R558
value_stmt ::= label_decl? value_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R559
volatile_stmt ::= label_decl? volatile_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R560
implicit_stmt ::= label_decl? implicit_ (<<list implicit_spec>> | none_) { pin = 3 }
// R561
implicit_spec ::= ((integer_ | real_ | complex_ | logical_ | character_ | (double_ precision_) | doubleprecision_ | byte_) '(' <<list letter_spec>> ')')
                 | (declaration_type_spec '(' <<list letter_spec>> ')')
// that's a crutch to parse intrinsic_type_spec without kindparam
// R562
letter_spec ::= fidentifier ('-' fidentifier)? { pin = 1 }
// R563
namelist_stmt ::= label_decl? namelist_ '/' entity_decl '/' <<list data_name>> ((',')? '/' entity_decl '/' <<list data_name>>)* { pin = 2; extends=specification_stmt }
// R564 is trivial
// R565
equivalence_stmt ::= label_decl? equivalence_ <<list equivalence_set>> { pin = 3; extends=specification_stmt }
// R566
equivalence_set ::= '(' equivalence_object ',' <<list equivalence_object>> ')'
// R567
equivalence_object ::= substring | data_path
// R568
common_stmt ::= label_decl? common_ (('/' common_block_decl? '/') | '//')? <<list common_block_object>> ((',')? (('/' common_block_decl? '/') | '//') <<list common_block_object>>)* { pin = 2; extends=specification_stmt }
common_block_decl ::= fidentifier {
    implements=['org.jetbrains.fortran.lang.psi.ext.FortranNamedElement'
                'org.jetbrains.fortran.lang.psi.ext.FortranReferenceElement']
    mixin='org.jetbrains.fortran.lang.psi.mixin.FortranCommonBlockDeclImplMixin'
}
// R569
common_block_object ::= data_name ('(' array_spec ')')?

// Clause 6
// R601 is implemented in clause 7
// R602
private variable ::= designator //| expr
// R603 - 607 are trivial
// R608
substring ::= parent_string '(' substring_range ')'
// R609
parent_string ::= data_path | string_literal
// R610
substring_range ::= (expr)? ':' (expr)?
// R611
data_path ::= data_path_start (data_path_part)* {
  implements = [ "org.jetbrains.fortran.lang.psi.ext.FortranReferenceElement"
                     "org.jetbrains.fortran.lang.psi.ext.FortranNamedElement"
                    "com.intellij.psi.PsiNameIdentifierOwner"]
  mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranDataPathImplMixin"
  elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranDataPathStub'
}
data_path_start ::= data_reference_element { elementType = data_path }
left data_path_part ::= ('%' data_reference_element) { elementType = data_path }
// R612
private data_reference_element ::= fidentifier ('(' <<list section_subscript>>? ')')? (image_selector)?
data_name ::= fidentifier { elementType = data_path }
// R613 - 614 are trivial
// R615 - 618 are excrescent
// R619 is trivial
// R620
section_subscript ::= (fidentifier '=' expr) | subscript_triplet | expr
// R621
subscript_triplet ::= (expr)? ':' (expr)? (':' expr)?
// R622 - 623 are trivial
// R624
image_selector ::= '[' <<list expr>> ']'  { pin = 1 }
// R625
// R626
allocate_stmt ::= label_decl? allocate_ '(' (type_spec '::')? <<list allocation>> (',' <<list parameters_spec>>)? ')' { pin = 2; extends=action_stmt }
// R627 is not for parser
// R628 - 630 are trivial
// R631
allocation ::= allocate_object ('(' <<list allocate_shape_spec>> ')')? ('[' allocate_coarray_spec ']')?
// R632
private allocate_object ::= (data_path) !'='
// R633
allocate_shape_spec ::= (expr ':')? expr
// R634 - 635 are trivial
// R636
allocate_coarray_spec ::= ( <<list allocate_coshape_spec>> ',' )? (expr ':')? '*'
// R637
allocate_coshape_spec ::= (expr ':')? expr
// R638
nullify_stmt ::= label_decl? nullify_ '(' <<list pointer_object>> ')' { pin = 2; extends=action_stmt }
// R639
pointer_object ::= data_path
// R640
deallocate_stmt ::= label_decl? deallocate_ '(' <<list allocate_object>> (',' <<list parameters_spec>>)? ')' { pin = 2; extends=action_stmt }
// R641 is not for parser

// Clause 7
// expressions in bnf grammar must be defined in a special order
// R701 - R722 + R304 + R305 + R601
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr { pin = 2 }
private defined_binary_op ::= defoperator
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
or_expr     ::= expr '.or.' expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
and_expr    ::= expr '.and.' expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
not_expr    ::= '.not.' expr { pin = 1 }
rel_expr    ::= expr rel_op expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
add_expr    ::= expr ('+' | '-') expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
unary_add_expr ::= ('+' | '-') expr { pin= 2 }
mult_expr   ::= expr ('*' | '/') expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  pin = 2
}
power_expr  ::= expr '**' expr {
  implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr'
  rightAssociative=true
  pin = 2
}
def_unary_operator_expr ::= defined_unary_op expr { pin = 1 }
private defined_unary_op ::= defoperator
private primary ::= constant | designator | (function_reference !'(') | (array_constructor !'(') /*| structure_constructor*/ | parenthesised_expr /*| type_param_inquiry */ { extends=expr }
parenthesised_expr ::= '(' expr ')' { pin = 1 }
// R455
structure_constructor ::= (fidentifier '(' <<list component_spec>> ')' !'(')
                         | (derived_type_spec ('(' <<list type_param_spec>> ')')?) { extends=expr }
// R468
array_constructor ::= ('(/' ac_spec '/)') | ('[' ac_spec ']') { extends=expr }
// R601
designator ::= (data_path !"(") | substring { extends=expr }
// R304, R305 modified
constant ::= floatingpointliteral | doubleprecisionliteral | integerliteral | complex_literal
            | logical_literal | string_literal | boz_literal { extends=expr }
logical_literal ::= truekwd | falsekwd

// R724 - 731 are trivial

// R732
assignment_stmt ::=  label_decl? designator '=' expr {implements='org.jetbrains.fortran.lang.psi.FortranBinaryExpr' pin = 3; extends=action_stmt } // it was a variable here in the standard but we don't want to match an expression
// R733
pointer_assignment_stmt ::= pointer_a_with_data_pointer | pointer_a_with_proc_pointer { extends=action_stmt }
private pointer_a_with_data_pointer ::= label_decl? data_pointer_object (('(' <<list bounds_remapping>> ')')
                                | ('(' <<list bounds_spec>>')')?) '=>' variable { pin = 4 }
private pointer_a_with_proc_pointer ::= label_decl? proc_pointer_object '=>' proc_target { pin = 3 }
// R734
data_pointer_object ::= (data_name !("%" | "(")) | (variable /*'%' fidentifier*/)
// R735
bounds_spec ::= expr ':'
// R736
bounds_remapping ::= expr ':' expr
// R737 is trivial
// R738 + R739
proc_pointer_object ::= (fidentifier !("%" | "(")) | (variable/* '%' fidentifier*/)
// R740
proc_target ::= expr | (variable '%' fidentifier) | fidentifier // last two options may be parsed as expr. Need to check later
// R741
where_stmt ::= label_decl? where_ '(' expr ')' assignment_stmt { pin = 6; extends=action_stmt}
// R742
where_construct ::= where_construct_stmt eol+ block (masked_elsewhere_stmt eol+ block)*
                    (elsewhere_stmt eol+ block)? end_where_stmt { pin = 1; extends=executable_construct }
// R743
where_construct_stmt ::= label_decl? construct_name_decl? where_ '(' expr ')'
// R744
// R745, R746 are trivial
// R747
masked_elsewhere_stmt ::= label_decl? ((else_ where_) | elsewhere_) '(' expr ')' construct_name? { pin = 3 }
// R748
elsewhere_stmt ::= label_decl? ((else_ where_) | elsewhere_) construct_name? { pin = 3 }
// R749
end_where_stmt ::= label_decl? ((end_ where_) | endwhere_) construct_name? { pin = 2 }
// R750
forall_construct ::= forall_construct_stmt eol+ block end_forall_stmt { pin = 1; extends=executable_construct }
// R751
forall_construct_stmt ::= label_decl? construct_name_decl? forall_ forall_header
// R752
forall_header ::= '(' (type_spec '::')? <<list forall_triplet_spec>> (',' expr)? ')' {pin=1}
// R753 + 754 + 755
forall_triplet_spec ::= data_name '=' expr ':' expr (':' expr)? {pin=2}
// R756
// R757
private forall_assignment_stmt ::= assignment_stmt | pointer_assignment_stmt
// R758
end_forall_stmt ::= label_decl? ((end_ forall_) | endforall_) construct_name? { pin = 2 }
// R759
forall_stmt ::= label_decl? forall_ forall_header forall_assignment_stmt { pin = 4; extends=action_stmt }


// Clause 8
// R801 + R208 we parse statements in any order while the standard has some restrictions. We'll check them in code revisions
block ::= (eol | execution_part_construct)* {
    elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranBlockStub'
    mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranBlockImplMixin'
}
// R802
associate_construct ::= associate_stmt eol+ block end_associate_stmt { pin = 1; extends=executable_construct }
// R803
associate_stmt ::= label_decl? construct_name_decl? associate_ '(' <<list association>> ')' { pin = 3 }
// R804
association ::= local_name '=>' selector { pin = 2 }
// R805
private selector ::= expr | variable
// R806
end_associate_stmt ::= label_decl? ((end_ associate_) | endassociate_) construct_name? { pin = 2 }
// R807
block_construct ::= block_stmt eol+ block end_block_stmt { pin = 1; extends=executable_construct }
// R808
block_stmt ::= label_decl? construct_name_decl? block_
// R809
end_block_stmt ::= label_decl? ((end_ block_) | endblock_) construct_name? {pin = 2 }
// R810
critical_construct ::= critical_stmt eol+ block end_critical_stmt { pin = 1; extends=executable_construct }
// R811
critical_stmt ::= label_decl? construct_name_decl? critical_ { pin = 3 }
// R812
end_critical_stmt ::= label_decl? ((end_ critical_) | endcritical_) construct_name { pin = 2 }
// R813 simplified compared to standard
external labeled_do_construct ::= parseLabeledDoConstruct
// R814
nonlabel_do_construct ::= nonlabel_do_stmt eol+ block end_do { pin = 1; extends=executable_construct}
// R815 unused
// R816
//label_do_stmt ::= (identifier ':')? do label loop_control? { pin = 3 }
// R817
nonlabel_do_stmt ::= label_decl? construct_name_decl? do_ loop_control? { pin = 3 }
// R818
loop_control ::= while_loop_stmt | concurrent_loop_stmt | id_loop_stmt
id_loop_stmt ::= variable '=' expr ',' expr (',' expr)? {pin=1}
while_loop_stmt ::= while_ '(' expr ')' {pin=1}
concurrent_loop_stmt ::= concurrent_ forall_header {pin = 1}
// R819, R820 are trivial
// R821
private end_do ::= end_do_stmt //| continue at the end of a loop is f77 specific feature
// R822
end_do_stmt ::= label_decl? (end_ do_ | enddo_) construct_name? { pin = 2}
// R823 - 830 are parsed manually
// R831
cycle_stmt ::= label_decl? cycle_ (data_name)? { pin = 2; extends=action_stmt }
// R832
if_construct ::= if_then_stmt eol+ block (else_if_stmt eol+ block)* (else_stmt eol+ block)? end_if_stmt { pin = 1; extends=executable_construct }
// R833
if_then_stmt ::= label_decl? construct_name_decl? if_ '(' expr ')' then_ { pin = 3 }
// R834
else_if_stmt ::= label_decl? ((else_ if_)|elseif_) '(' expr ')' then_ construct_name? { pin = 2 }
// R835
else_stmt ::= label_decl? else_ construct_name? { pin = 2 }
// R836
end_if_stmt ::= label_decl? ((end_ if_)|endif_) construct_name? { pin = 2 }
// R837
if_stmt ::= label_decl? if_ '(' expr ')' action_stmt {pin=6; extends=action_stmt}
// R838
case_construct ::= select_case_stmt eol+ (case_stmt eol+ block)* end_select_stmt { pin = 1; extends=executable_construct }
// R839
select_case_stmt ::= label_decl? construct_name_decl? select_ case_ '(' expr ')' { pin = 4 }
// R840
case_stmt ::= label_decl? case_ case_selector construct_name? { pin = 2 }
// R841
end_select_stmt ::= label_decl? ((end_ select_) | endselect_ ) construct_name? { pin = 2 }
// R842 is trivial
// R843
case_selector ::= ('(' <<list case_value_range>> ')') | default_
// R844
case_value_range ::= (expr ':' expr) | (expr ':') | expr | (':' expr)
// R845 is trivial
// R846
select_type_construct ::= select_type_stmt eol+ (type_guard_stmt eol+ block)* end_select_stmt { pin = 1; extends=executable_construct }
// R847
select_type_stmt ::= label_decl? construct_name_decl? select_ type_ '(' (fidentifier '=>')? selector ')' { pin = 4 }
// R848
type_guard_stmt ::= (typeis_guard | classis_guard | classdefault_guard) construct_name? { pin = 1 }
private typeis_guard ::= type_ is_ '(' type_spec ')' { pin = 1 }
private classis_guard ::= class_ is_ '(' derived_type_spec ')' { pin = 2 }
private classdefault_guard ::= class_ default_ { pin = 2 }
// R849 is a copy of R841
// R850
exit_stmt ::= label_decl? exit_ (construct_name)? { pin = 2; extends=action_stmt }
// R851
goto_stmt ::= label_decl? ((go_ to_) | goto_) label { pin = 3; extends=action_stmt }
// R852 deprecated
computed_goto_stmt ::= label_decl? ((go_ to_) | goto_) '(' <<list label>> ')' (',')? expr { pin = 3; extends=action_stmt }
// R853 deprecated
arithmetic_if_stmt ::= label_decl? if_ '(' expr ')' label ',' label ',' label { pin = 6; extends=action_stmt }
// R854
continue_stmt ::= label_decl? continue_ { pin = 2; extends=action_stmt }
// R855
stop_stmt ::= label_decl? stop_ !("=" | "=>" | '[' | "%") (expr)? { pin = 2; extends=action_stmt }
// R856
error_stop_stmt ::= label_decl? error_ stop_ (expr)? { pin = 2; extends=action_stmt }
// R857 it trivial
// R858
sync_all_stmt ::= label_decl? ((sync_ all_) | syncall_) ('(' ( <<list parameters_spec>> )? ')')? { pin = 2; extends=action_stmt }
// R859 is not for parser
// R860
sync_images_stmt ::= label_decl? ((sync_ images_) | syncimages_) '(' image_set (',' <<list parameters_spec>>)?')' { pin = 2; extends=action_stmt }
// R861
image_set ::= '*' | expr
// R862
sync_memory_stmt ::= label_decl? ((sync_ memory_) | syncmemory_) ('(' (<<list parameters_spec>>)? ')')? { pin = 2; extends=action_stmt }
// R863
lock_stmt ::= label_decl? lock_ '(' variable (',' <<list lock_stat>>)? ')' { pin = 2; extends=action_stmt }
// R864
lock_stat ::=  (fidentifier fidentifier '=' variable) | parameters_spec
// lock_stat ::= (acquired lock '=' variable) | sync_stat
// R865
unlock_stmt ::= label_decl? unlock_ '(' variable (',' <<list parameters_spec>>)? ')' { pin = 2; extends=action_stmt }
// R866 is trivial

// Clause 9 (ready)
// R901 don't need now
//io_unit ::= '*' | variable | expr
// R902, R903 are trivial
// R904
open_stmt ::= label_decl? open_ '(' <<list parameters_spec_with_unit_decl>> ')' {pin = 3; extends=action_stmt}
// R905 is not for parser
// R906, R907 are trivial
// R908
close_stmt ::= label_decl? close_ '(' <<list parameters_spec_with_unit>> ')' {pin = 3; extends=action_stmt }
// R909 is not for parser
// R910
read_stmt ::= label_decl? read_ (io_control_read | format_read) {pin = 2; extends=action_stmt}
private io_control_read ::= '(' io_control_spec_list ')' ','? <<list input_item>>? { pin = 1}
private format_read ::= parameter_value (',' <<list input_item>>?)?
// R911
write_stmt ::= label_decl? write_ '(' io_control_spec_list ')' ','? <<list output_item>>? { pin= 3; extends=action_stmt }
// R912
print_stmt ::= label_decl? print_ parameter_value ','? <<list output_item>>? { pin = 3; extends=action_stmt }
// R913 is not for parser
// R914 is trivial
// R915
private parameter_value ::= '*'  | label_or_expression
// we can match label when it's really an expression, but expression matches a label too
// R916
input_item ::= variable | io_implied_do_input
// R917
output_item ::= io_implied_do_output | expr
// R918 + R920
io_implied_do_input ::= '(' <<list io_implied_do_object_input>> ',' id_loop_stmt ')' { pin = 4 }
io_implied_do_output ::= '(' <<list io_implied_do_object_output>> ',' id_loop_stmt ')' { pin = 4 }
// R919
io_implied_do_object_input ::= input_item !'=' { pin = 2 }
io_implied_do_object_output ::= output_item !'=' { pin = 2 }
// R921 (unused maybe)
//dtv_type_spec ::= (type | classkwd) '(' derived_type_spec ')' { pin =1 }
// R922
wait_stmt ::= label_decl? wait_ '(' <<list parameters_spec_with_unit>> ')' { pin =2; extends=action_stmt }
// R923 is not for parser
// R924
backspace_stmt ::= label_decl? backspace_ (('(' <<list parameters_spec_with_unit>> ')') | expr ) { pin = 2; extends=action_stmt }
// R925
endfile_stmt ::= label_decl? endfile_ (('(' <<list parameters_spec_with_unit>> ')') | expr) { pin = 2; extends=action_stmt }
// R926
rewind_stmt ::= label_decl? rewind_ (('(' <<list parameters_spec_with_unit>> ')') | expr) { pin = 2; extends=action_stmt}
// R927 + R929 are not for parser
// R928
flush_stmt ::= label_decl? flush_ (('(' <<list parameters_spec_with_unit>> ')') | expr) { pin = 2; extends=action_stmt}
// R930
inquire_stmt ::= label_decl? inquire_ (inquire_with_iolength | ('(' <<list parameters_spec_with_unit>> ')'))  { pin = 2; extends=action_stmt}
private inquire_with_iolength ::= '(' iolength_ '=' expr /*variable */')' <<list output_item>> { pin = 2}
// R931 is not for parser

// Clause 10
// R1001
format_stmt ::= label_decl? format_ (('(' <<noncomalist format_item>>? ')')
              | ('('(<<noncomalist format_item>> ',')? '*' '(' <<noncomalist format_item>> ')'')' )) { pin = 2; extends=declaration_stmt }
private format_item ::= dataedit | control_edit | string_literal | (integerliteral? '(' <<list format_item>> ')')
control_edit ::= ":" | "$" | (integerliteral? '/') | (signed_int_literal dataedit)
// Clause 11
// R1101
main_program ::= (program_stmt_with_eol)? block internal_subprogram_part? end_program_stmt {
pin = 1; extends = program_unit
mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranMainProgramImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
private program_stmt_with_eol ::= program_stmt eol+ {pin = 1}
// R1102 +
program_stmt ::= label_decl? program_ program_unit_name { pin = 2 }
// R1103 +
end_program_stmt ::=  label_decl? (end_ &(eol|<<eof>>) | end_ program_ data_name? | endprogram_ data_name?) { pin = 2 }
// R1104
module ::= module_stmt eol+ block module_subprogram_part? end_module_stmt {
pin = 1; extends = program_unit
mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranModuleImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
// R1105
module_stmt ::= label_decl? module_ program_unit_name { pin = 2 }
// R1106
end_module_stmt ::= label_decl? (end_ &(eol|<<eof>>) | end_ module_ data_name? | endmodule_ data_name?) { pin = 2 }
// R1107
module_subprogram_part ::= contains_stmt eol+ (eol | module_subprogram)* {
    pin = 1
    elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranModuleSubprogramPartStub'
    mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranModuleSubprogramPartImplMixin'
}
// R1108
private module_subprogram ::= !(label_decl? (end_ | endmodule_ | endsubmodule_)) (function_subprogram | subroutine_subprogram | separate_module_subprogram | include_stmt) {
  pin = 1
  recoverWhile = module_subprogram_recover
}
private module_subprogram_recover ::= !(eol | end_ | endfunction_ | endsubroutine_ | endprocedure_)
// R1109
use_stmt ::= label_decl? use_ (use_stmt_only | use_stmt_rename) {
    pin = 2
    elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranStatementStub'
    mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranStmtImplMixin'
}
private use_stmt_rename ::= ((',' module_nature)? '::')? data_path (',' <<list rename_stmt>>)?
private use_stmt_only ::= ((',' module_nature)? '::')? data_path ',' only_ ':' (<<list only_stmt>>)? { pin = 5 }
// R1110
private module_nature ::= intrinsic_ | nonintrinsic_
// R1111
rename_stmt ::= (local_name '=>' data_name)
               |(operator_ '(' defoperator ')' '=>' operator_ '(' defoperator ')') {
  elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranRenameStmtStub'
  mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranRenameStmtImlMixin'
}
// R1112
only_stmt ::= rename_stmt | (data_name !'(') | generic_spec {
  elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranOnlyStmtStub'
  mixin = 'org.jetbrains.fortran.lang.psi.mixin.FortranOnlyStmtImplMixin'
}

local_name ::= fidentifier { elementType = entity_decl }
// R1113, R1114, R1115 are trivial
// R1116
submodule ::= submodule_stmt eol+ block module_subprogram_part? end_submodule_stmt {
pin = 1; extends = program_unit
mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranSubModuleImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
// R1117
submodule_stmt ::= label_decl? submodule_ '(' parent_identifier ')' program_unit_name { pin = 2 }
// R1118
parent_identifier ::= data_name (':' data_name)?
// R1119
end_submodule_stmt ::= label_decl? (end_ &(eol|<<eof>>) | end_ submodule_ data_name? | endsubmodule_ data_name?)  { pin = 2 }
// R1120
block_data ::= block_data_stmt eol+ block end_block_data_stmt {
pin = 1; extends = program_unit
mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranBlockDataImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
// R1121
block_data_stmt ::= label_decl? (blockdata_ | (block_ data_)) program_unit_name? { pin = 2 }
// R1122
end_block_data_stmt ::= label_decl? (end_ &(eol|<<eof>>)
                      | end_ (block_ data_ | blockdata_) data_name?
                      | endblock_ data_ data_name?
                      | endblockdata_ data_name?)  { pin = 2 }

// Clause 12
// R1201
interface_block ::= interface_stmt eol+ interface_specification end_interface_stmt {
 pin = 1; extends = declaration_construct
 mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranInterfaceBlockImplMixin"
 elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
 stubClass = 'org.jetbrains.fortran.lang.stubs.FortranInterfaceBlockStub'
}
// R1202
interface_specification ::= !endinterface_keys ((eol) | function_subprogram | subroutine_subprogram | (procedure_stmt))* {
pin = 1
recoverWhile = interface_recover
 mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranInterfaceSpecificationImplMixin"
 elementTypeFactory ="org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory"
 stubClass = 'org.jetbrains.fortran.lang.stubs.FortranInterfaceSpecificationStub'
}
private endinterface_keys ::= !assignment_stmt label_decl? (end_ | endinterface_)
private interface_recover ::= !(eol | endinterface_keys)
// R1203
interface_stmt ::= label_decl? ((abstract_ interface_) | (interface_ (local_name !'(' | generic_spec)?)) { pin = 2 }
// R1204
end_interface_stmt ::= label_decl? ((end_ interface_) | endinterface_) (data_name !'(' | generic_spec)? { pin = 2 }
// R1205
// R1206
procedure_stmt ::= label_decl? (module_)? procedure_ ('::')? <<list entity_decl>> { pin = 3 }
// R1207
generic_spec ::= (operator_ '(' (defoperator | '**' | '*' | '/' | '+' | '-' | '//' | rel_op | '.not.' | '.and.' | '.or.' | '.eqv.' | '.neqv.') ')')
              | assignment_ '(' '=' ')' | defined_io_generic_spec
// R1208
defined_io_generic_spec ::= read_ '(' (formatted_ | unformatted_) ')'
                           | write_ '(' (formatted_ | unformatted_) ')'
// R1209
import_stmt ::= label_decl? import_ ('::'? <<list fidentifier>>)? { pin =2 }
// R1210
external_stmt ::= label_decl? external_ ('::')? <<list data_name>> { pin = 2; extends=specification_stmt }
// R1211
procedure_declaration_stmt ::= label_decl? procedure_ '(' proc_interface? ')' ((',' proc_attr_spec)* '::')? <<list proc_decl>> { pin = 2; extends=declaration_stmt }
// R1212
proc_interface ::= fidentifier | declaration_type_spec
// R1213
proc_attr_spec ::= access_spec | language_binding_spec | (intent_ '(' intent_spec ')')
                  | optional_ | pointer_ | save_
// R1214
proc_decl ::= fidentifier ('=>' proc_pointer_init)?
// R1215 is trivial
// R1216
proc_pointer_init ::= function_reference | fidentifier
// R1217 is trivial
// R1218
intrinsic_stmt ::= label_decl? intrinsic_ ('::')? <<list fidentifier>> { pin = 2; extends=specification_stmt }
// R1219
function_reference ::= procedure_designator '(' <<list actual_arg_spec>>? ')' { pin = 4; extends=expr }
// R1220
call_stmt ::= label_decl? call_ procedure_designator ('(' <<list actual_arg_spec>>? ')')? { pin = 2; extends=action_stmt }
// R1221
procedure_designator ::= data_path
// R1222
actual_arg_spec ::= (fidentifier '=')? actual_arg
// 1223
actual_arg ::= expr | alt_return_spec // expr matches variable, procedure-name and proc-component-ref
// 1224 deprecated
alt_return_spec ::= '*' label
// R1225
prefix ::= prefix_spec+ { pin = 1 }
// R1226
prefix_spec ::= declaration_type_spec | elemental_ | impure_ | module_ | pure_ | recursive_
// R1227
function_subprogram ::= function_stmt eol+ block internal_subprogram_part? end_function_stmt {
  pin = 1; extends = program_unit
  mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranFunctionSubprogramImplMixin"
    stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
    elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
// R1228
function_stmt ::= label_decl? prefix? function_ program_unit_name '(' <<list data_name>>? ')' suffix? { pin = 3; }
// R1229 and R1230 are trivial
// R1231
suffix ::= (language_binding_spec (result_ '(' data_name ')')?) | (result_ '(' data_name ')' (language_binding_spec)?)
// R1232
end_function_stmt ::= label_decl? (end_ &(eol|<<eof>>) | end_ function_ data_name? | endfunction_ data_name?) { pin = 2 }
// R1233
subroutine_subprogram ::= subroutine_stmt eol+ block internal_subprogram_part? end_subroutine_stmt {
    pin = 1; extends = program_unit
    mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranSubroutineSubprogramImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
// R1234
subroutine_stmt ::= label_decl? prefix? subroutine_ program_unit_name ('(' <<list dummy_arg>>? ')' language_binding_spec? )?  {
pin = 3; }
// R1235
private dummy_arg ::= '*' | data_name
// R1236
end_subroutine_stmt ::= label_decl? (end_ &(eol|<<eof>>) | end_ subroutine_ data_name? | endsubroutine_ data_name?) { pin = 2 }
// R1237
separate_module_subprogram ::= mp_subprogram_stmt eol+ block internal_subprogram_part? end_mp_subprogram_stmt {
    pin = 1; extends = program_unit
    mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranSeparateModuleSubprogramImplMixin"
  stubClass = 'org.jetbrains.fortran.lang.stubs.FortranProgramUnitStub'
  elementTypeFactory ='org.jetbrains.fortran.lang.stubs.FortranStubFactoryKt.fortranStubFactory'
}
// R1238
mp_subprogram_stmt ::= label_decl? module_ procedure_ program_unit_name {
pin = 3;
}
// R1239
end_mp_subprogram_stmt ::= label_decl? (end_ &(eol|<<eof>>) | end_ procedure_ fidentifier? | endprocedure_ fidentifier?) { pin = 2}
// R1240
entry_stmt ::= label_decl? entry_ fidentifier ('(' <<list dummy_arg>>? ')' suffix? )? { pin = 2; extends=declaration_stmt }
// R1241
return_stmt ::= label_decl? return_ (expr)? { pin = 2; extends=action_stmt}
// R1242
contains_stmt ::= label_decl? contains_  { pin = 2 }
// R1243
stmt_function_stmt ::= label_decl? fidentifier '(' <<list fidentifier>>? ')' '=' expr { pin = 6; extends=declaration_stmt }

// deleted statements
pause_stmt ::= label_decl? pause_ (expr)? { pin = 2; extends=action_stmt }
assign_stmt ::= label_decl? assign_ label to_ variable { pin = 2; extends=action_stmt }
assigned_goto_stmt ::= label_decl? (goto_ | (go_ to_)) fidentifier (','? '(' <<list label_decl>> ')' )?  { pin = 3; extends=action_stmt }
include_stmt ::= label_decl? include_ string_literal {
    pin = 2
    mixin = "org.jetbrains.fortran.lang.psi.mixin.FortranIncludeStmtMixin"
}

// nonstandard
accept_stmt ::= label_decl? accept_  parameter_value (',' <<list input_item>>)?  {pin = 2; extends=action_stmt}
encode_stmt ::= label_decl? encode_ '(' expr ',' parameter_value ',' designator (',' <<list parameters_spec>>)?')' <<list output_item>> { pin = 2; extends=action_stmt}
decode_stmt ::= label_decl? decode_ '(' expr ',' parameter_value ',' designator (',' <<list parameters_spec>>)?')' <<list input_item>> { pin = 2; extends=action_stmt }
type_stmt ::= label_decl? type_ parameter_value (','? <<list output_item>>?) { pin = 4; extends=action_stmt }
